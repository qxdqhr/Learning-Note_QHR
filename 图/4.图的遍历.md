# 图的遍历

- 给定一个图,为其创建一个邻接矩阵

- 图没有开始节点,需要指定某一结点作为起始节点

# DFS深度优先遍历(纵向)

一条道跑到黑,撞墙才折返(回到上一个节点)

![image-20200928182951982](.\image-20200928182951982-1602069901624.png)

## 邻接矩阵

|               | v<sub>1</sub> | v<sub>2</sub> | v<sub>3</sub> | v<sub>4</sub> | v<sub>5</sub> |
| ------------- | ------------- | ------------- | ------------- | ------------- | :------------ |
| v<sub>1</sub> | 0             | 1             | 0             | 1             | 1             |
| v<sub>2</sub> | 1             | 0             | 1             | 1             | 1             |
| v<sub>3</sub> | 0             | 1             | 0             | 0             | 0             |
| v<sub>4</sub> | 1             | 1             | 0             | 0             | 1             |
| v<sub>5</sub> | 1             | 1             | 0             | 1             | 0             |

## 如何判断某一结点是否遍历过:标记

- 使用标记数组进行标记

## 基本流程

1. 确定一个开始节点,申请一个标记数组
2. 设定当前节点为开始节点;
3. 当前节点执行遍历操作(打印),将其加入标记数组中;
4. 在邻接矩阵中找到第一个与当前节点有关的,未被遍历过的节点
5. 将当前节点更改为新结点;
6. 重复3-5步骤,直至无法继续向下遍历并且标记数组未满
   1. 某些情况下可以节点全部遍历完成(标记数组全满)
7. 寻找当前节点的源节点(从哪里遍历来的)
8. 重复4,5步骤直至节点全部遍历完成
   1. 如果又出现6中情况,重复7,8

## 举例流程(4为开始节点)

1. 将开始节点4定为当前节点:
   1. 判断标记数组中是否标记过此节点
      1. 未标记则执行遍历操作
      2. 开始节点最初不会被标记
   2. 遍历操作后,找到第一个与当前节点有关且未被遍历过的的节点
      1. 在邻接矩阵第4行的元素中寻找第一个值为1的节点
      2. 节点1为下一节点
2. 遍历节点1:
   1. 判断标记数组中第1个位置(下标+1)是否值为1,
      1. 不为1则执行遍历操作
   2. 找到第一个与当前节点(1)有关且未被遍历过的的节点
      1. 邻接矩阵查看第1行的元素中第一个值为1的节点
         1. 此时第一个值为1的节点是v<sub>2</sub>,判断标记数组中v<sub>2</sub>是否被标记
      2. 节点2为下一节点
3. 遍历节点2:
   1. 判断标记数组中第2个位置(下标+1)是否值为1,
      1. 不为1则执行遍历操作
   2. 找到第一个与当前节点(2)有关且未被遍历过的的节点
      1. 邻接矩阵查看第2行的元素中第一个值为1的节点
         1. 此时第一个值为1的节点是v<sub>1</sub>,判断标记数组中v<sub>1</sub>是否被标记
      2. 节点2为下一节点

## 代码示例:

```c
#include<stdio.h>
void DFS(Graph * pGraph,int nBegin)
{
	if(pGraph == NULL) return ;
	//申请标记数组
	int * pMark  = NULL;
	
}
```





# BFS广度优先遍历(横向)

1. 创建标记数组
2. 创建辅助队列
3. 将开始节点入队,并在标记数组中标记
4. 